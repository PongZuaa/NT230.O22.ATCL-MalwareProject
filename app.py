from flask import Flask, request, render_template, send_file, jsonify
import os
from werkzeug.utils import secure_filename
import combine
import pandas as pd

app = Flask(__name__)

# Tạo thư mục tạm thời
temp_dir = os.path.join(app.root_path, 'temp')
if not os.path.exists(temp_dir):
    os.makedirs(temp_dir)

@app.route('/')
def home():
    # Đọc nội dung của file HTML và trả về nó trong response
    with open('extract_feature.html', 'r', encoding='utf-8') as file:
        html_content = file.read()
    return html_content

@app.route('/extract', methods=['POST'])
def extract_feature():
    file_exe = request.files['file_exe']
        
    if 'file_exe' not in request.files:
        return 'Không tìm thấy file!'
    
    file_exe = request.files['file_exe']

    if file_exe.filename == '':
        return 'File không được chọn!'
    
    # Lấy loại file từ request
    file_type = request.form['file_type']
    # # Convert file_type sang số nguyên
    print(file_type)
    
    # Lưu file exe vào thư mục tạm thời
    file_exe_path = os.path.join(app.root_path, file_exe.filename)
    file_exe.save(file_exe_path)

    # Thực hiện các quá trình xử lý
    os.system(f'python extract-header-1.py {file_exe_path} {file_type}')
    os.system(f'python cfg-emulated.py ')

    # Đường dẫn đến file CSV và file đồ thị
    csv_file_path = os.path.join(app.root_path,'output_dataset_header.csv')
    graph_file_path = os.path.join(app.root_path, 'test.txt')

    # Đọc nội dung của file HTML và trả về nó trong response
    with open('after_extract.html', 'r', encoding='utf-8') as file:
        html_content = file.read()
    
    # Thay thế các placeholder trong template bằng đường dẫn thực tế của các file
    html_content = html_content.replace('{{ csv_file }}', csv_file_path)
    html_content = html_content.replace('{{ graph_file }}', graph_file_path)

    return html_content, file_type

# @app.route('/download/<path:filename>')
# def download(filename):
#     # Xây dựng đường dẫn đầy đủ của file để người dùng có thể tải về
#     file_path = os.path.join(app.root_path, filename)
#     return send_file(file_path, as_attachment=True)

@app.route('/download/csv')
def download_csv():
    # Xây dựng đường dẫn đầy đủ của file CSV
    csv_file_path = '.\\temp\\output_dataset_header.csv'
    return send_file(csv_file_path, as_attachment=True)

@app.route('/download/graph')
def download_graph():
    # Xây dựng đường dẫn đầy đủ của file đồ thị
    graph_file_path = '.\\temp\\test.txt'
    return send_file(graph_file_path, as_attachment=True)

# @app.route('/upload_for_prediction')
# def upload_for_prediction():
#     with open('upload_for_prediction.html', 'r', encoding='utf-8') as file:
#         html_content = file.read()
#     return html_content

@app.route('/predict', methods=['POST'])
def predict():
    # Đọc file CSV vào một DataFrame
    df = pd.read_csv('.\\temp\\output_dataset_header.csv')

    # Lấy giá trị đầu tiên từ cột 'Type'
    file_type = df['Type'].iloc[0]
    
    csv_file_path = '.\\temp\\output_dataset_header.csv'
    graph_file_path = '.\\temp\\test.txt'

    # Gọi hàm dự đoán từ combine.py
    result = combine.predict(csv_file_path, graph_file_path, file_type)
    
    # Gọi hàm dự đoán từ combine.py và truyền kết quả trực tiếp vào render_template
    return render_template('.\\tempplates\\result.html', **result)

if __name__ == '__main__':
    app.run(debug=True)
